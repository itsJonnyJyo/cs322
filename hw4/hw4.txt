------------------------------------------------------------------------
CS322 Languages and Compiler Design II                        Homework 4
------------------------------------------------------------------------

This is the final homework assignment for CS 322.  It is intended to
develop your understanding and experience with several of the topics
that we have covered in the last weeks of the course, including:

 - code generation for intermediate languages in general, and LLVM
   in particular
 - the use of multiple compilation schemes
 - the use of lambda expressions
 - the role of a runtime system

There are two exercises, both based on the StevieLLVM.zip codebase that
is available from D2L.  This particular assignment has some dependencies
on a specific combination of software packages that are installed on
the LinuxLab machines.  In particular, it requires:

- Java 8 (also known as JDK 1.8), which extends previous versions of
  the Java language and toolset with support for "lambda expressions"

- LLVM 3.4; more recent versions of the LLVM toolset are available
  (version 3.8.0 is the latest release available as I write this), but
  there are some small differences in the syntax of the LLVM assembly
  language between the different versions.

It is possible to download and install copies of both of these on other
machines (visit http://www.oracle.com/technetwork/java/index.html
for the former and http://llvm.org/releases/ for the latter), but I
would *strongly* recommend that you plan to complete this assignment
on the LinuxLab machines and save yourself the trouble and overhead of
installing new software on a different computer.

Please pay careful attention to the README.txt file for details about
how to set up and use the StevieLLVM compiler, and to NOTES.txt for more
information about the implementation of the compiler.  These materials
are provided as documentation to help you complete this assignment.

------------------------------------------------------------------------
Question 1:
-----------
Consider the following StevieFun program (source code is provided
in below.stv):

    void main() {
      print below(3, 4, 5);
    }

    int below(int x, int y, int z) {
       while ((x < y) && (x < z)) {
         x = x + 1;
       }
       return x;
    }

a) Following the examples that were presented in class, construct a
handwritten, LLVM version of this program in a file called "below.ll"
that can be compiled, linked with the runtime.c library, and executed.

WARNING: Of course it is possible to generate an LLVM version of
below.stv using the StevieLLVM compiler; I will even ask you to do
this below.  But you are strongly discouraged from trying to do that
before you have completed this part of the assignment.  This is not
an attempt to prevent you from "cheating"; instead, if you look at
the output that is produced by StevieLLVM before you try to solve this
by hand, then it could corrupt your thinking and make the rest of the
exercise much harder for you!

b) Compile below.stv using StevieLLVM and inspect the generated demo.ll
and demo.s files; in fact, for clarity, you will likely find that it is
easier to understand the generated LLVM code if you look at the output
from the following command, instead of (or in addition to) the original
version of demo.ll:

   opt-3.4 -S -mem2reg demo.ll

How do the LLVM implementations of the below function differ between
the version you wrote by hand and the version that was generated by
StevieLLVM?  (If the two versions do not differ in fundamental ways,
go back to Part (a) and rewrite your code in a more intuitive manner;
as mentioned above, this will be harder to do if you've already let your
thinking be corrupted by peeking at the compiled version of the code.)

c) Can we improve the code that is generated by StevieFun (Part (b))
to better match the more natural code that a human might write for
the same problem (Part (a))?  As a first step, the implementation of
the Expr class contains the following definition of a new compilation
scheme for expressions (i.e., in class Expr) called compileCond():

  /** Generate LLVM code that will evaluate this expression
   *  and then branch to one of the specified LLVM blocks
   *  depending on whether the expression is true or false.
   *  Of course, this only makes sense for expressions that
   *  produce boolean values; for everything else, the
   *  default implementation below will be sufficient (and
   *  should never actually be used if we ensure that our
   *  programs are type checked before we attempt to compile
   *  them).
   */
  Code compileCond(final llvm.Function fn,
                   final llvm.Block t,
                   final llvm.Block f) {
    System.err.println("compileCond() method NOT IMPLEMENTED");
    System.exit(1);
    return null; // not reached
  }

However, there are no uses of this method in other parts of the program,
and there are no implementations for this method in any of the subclasses
of Expr.  To complete this part of the assignment, you are required to:

- Add suitable implementations for the compileCond() method in the Bool,
  LAnd, and Lt classes.  (For completeness, you might also want to add
  implementations for compileCond in the Var, Nth, LOr, and EqEq classes,
  which can also produce boolean results.  However, I will not ask you to
  run any tests that rely on having implementations for those methods.)
  Note that you do NOT need to modify the code in the Expr implementation
  of compileCond given above.

- Modify the code for the While class to take advantage of the new
  compileCond compilation scheme.  (Again, for completeness, there are
  other parts of the code where you might want to rake advantage of the
  compileCond scheme --- in the implementation of If, for example ---
  but doing that is not required for this exercise.)

- Demonstrate that your modified version of StevieLLVM will now produce
  code for below.stv that is now very close (it doesn't have to be
  identical) to the version that you wrote originally by hand.

------------------------------------------------------------------------
Question 2:
-----------
The StevieLLVM compiler includes support for programs that manipulate
arrays.  The specific features are as follows:

- The syntax T[] describes the type of arrays whose elements are all
  values of type T.  In the abstract syntax, array types are represented
  using the ArrayType class.

- New arrays can be allocated using expressions of the form new T[size];
  this will create a new array of type T[] with size elements, assuming
  that size is an integer.  In the abstract syntax, new array expressions
  are represented by the NewArray class.

- Individual elements of an array can be accessed by using the standard
  notation arr[idx] to reference the idxth element of the array arr.
  The first element in any array has index 0, so a size 4 array of
  type T[], for example, will hold four elements of type T that can
  be referenced as a[0], a[1], a[2], and a[3].  Array accesses of
  this form can appear in expressions and on the left hand side of an
  assignment statement.  In both cases, array accesses are represented
  by the Nth class.

- An expression of the form length(arr) is supposed to return the
  number of elements in the array given by the expression, arr.
  For reasons described below, however, this operation does not work
  correctly in the current implementation, and always returns zero.
  In the abstract syntax, length expressions like this are represented
  using the Length class.

In principle, the constructs described here could be used with arbitrary
types of arrays.  For the purposes of this assignment however, we will
focus exclusively on arrays of type int[].  You will not be expected
to test or deliver code that will work with arrays of any other type.

The code for StevieLLVM includes an initial attempt to support these
features, providing abstract syntax classes with parsing, static
analysis, and basic compilation schemes.  The basic idea is to represent
an array as a pointer to a block of memory that stores the individual
array elements in consecutive locations, four bytes apart (because
we're assuming that int values are 4 bytes long).  The following
diagram illustrates an array stored in this form, assuming an array,
arr, whose first value is stored at address a:

     ---------------------------------------------------------
        ... | arr[0] | arr[1] | arr[2] | arr[3] | ...
     ---------------------------------------------------------
            a       a+4      a+8      a+12     a+16  ...

The current implementation, however, has several flaws:

a) The length of the array is not stored in memory, so there is no
   way to determine the length of an array at runtime, and no way to
   implement the length operation.

b) The storage for new arrays is allocated by using a function called
   XallocArray(), which has been implemented by a function in the (still)
   very simple runtime library, runtime.c, which in turn relies on a
   call to the standard C library function called malloc().  However,
   the implementation of this function does not check that the value
   of the size argument is valid (in particular, it should be greater
   than or equal to zero) and it does not test the return result that
   is produced by the call to malloc to make sure that it is not null.

c) Array accesses are not checked to ensure that the specified index
   is valid.  For example, a program that attempts to access an array
   element a[i] should fail at runtime if the value of i is either
   negative or greater than or equal to the length of the array.  Of
   course, it is hard to handle this fully in the current implementation
   because there is no way to determine the length of an arbitrary array.

Your task now is to change the expectations for generated code so that
arrays are represented in a different way (including extra information
about length) and to update the compilation rules and/or runtime
library support so that each of the issues above is properly addressed.
Specifically, you should modify the compiler so that every array of type
int[] stores an extra length field at the start of the array, shifting
regular array elements up by four bytes from the start of the array,
as shown in the following diagram.

     ---------------------------------------------------------
        ... | len    | arr[0] | arr[1] | arr[2] | ...
     ---------------------------------------------------------
            a       a+4      a+8      a+12     a+16  ...

Some implementation details/hints to help you with this task:

0) You are encouraged (and expected) to spend time studying the provided
   (albeit flawed) implementation of these array features so that you
   can understand the tools and techniques that you need to adapt to
   develop the new implementation.  The provided code includes some
   fairly extensive comments to guide you through this task.  You
   might also want to study the code that is produced by compiling
   simple examples with the StevieLLVM compiler: the included at.stv
   file is one obvious example to start with!

1) If the argument in a new array expression is negative, then the
   program should display an error message of the form "Invalid array
   size NNN", where NNN is replaced by the value of the size parameter
   that was specified in the new T[size] construct, and then terminate
   the program with an error code of 1; the latter can be accomplished
   in C code by executing exit(1);

2) If the malloc call in allocArray fails (i.e., returns a null pointer),
   then the program should display an error message of the form "Out
   of memory" and then terminate the program with an error code of 1.

3) If the index in an array access is invalid, then the program should
   display an error message of the form "Invalid array index NNN for
   array of size MMM" (where NNN is the specified index and MMM the
   length of the array) and then terminate the program with an error
   code of 1.

4) You may add new functions to the runtime library as necessary.
   The code for validating arguments in new array constructs and
   for printing out error messages should be written in C.  However,
   the compiler should generate LLVM code that checks for valid array
   index values, and that does not attempt to invoke a runtime library
   function unless the index is known to be invalid.

5) In LLVM code, you should follow a call to a function that will not
   return (because, for example, it is guaranteed to execute an exit(1)
   call) with an "unreachable" terminator.  The code to construct a
   suitable fragment of abstract syntax for this using the classes in
   the "llvm" folder would look something like this:

      new llvm.CallVoid(name, new Value[] { ... },
      new llvm.Unreachable())

   The Unreachable class shown here should not be used in other
   circumstances.

6) Do not underestimate the benefits of using diagrams when you are
   trying to write code that constructs abstract syntax for programs
   containing multiple blocks!

------------------------------------------------------------------------
How to submit:
--------------
You should submit a written report that describes your answers to each of
the questions above.  This report should be submitted electronically in
pdf or plain text format to the D2L dropbox by 11:59am on Wednesday, June 1.
No other formats can be accepted, so please do not submit documents in
Word or Open Office formats, and do not submit zip files, tar files, or
other archive formats it you wish to receive credit for this assignment.
If the requirement that you submit your solution in either pdf or plain
text formats is problematic for you in any way, then please contact
the instructor no later than five days before the submission deadline
to determine in other arrangements can be made to accommodate your needs.

The expectations for your answers to each of the parts of the question
are documented in the text above.  Nonetheless, past experience
suggests that some people may find some value in using the comments
like the following as an extra checklist before they submit:

  For Question 1:
    a) Be sure to include a commented listing of below.ll with your
    answer along with evidence that it "can be compiled, linked with
    the runtime.c library, and executed" to produce the expected
    result.

    b) You are expected to show how the two LLVM programs differ;
    you may well find it useful to include relevant parts of the
    generated code as a way to support your answer.

    c) Your answer should explain the method that you have used
    (again, including relevant code fragments is recommended where
    appropriate) and you should make it clear that you have satisfied
    each of three requirements that are listed in the bullet points
    at the end of the question.

  For Question 2:
    For each of Parts (a), (b), and (c), your answer should describe
    the changes that you have made to the code in Src.java and/or
    runtime.c, and provide evidence to show that each of the
    corresponding issues is "properly addressed".

------------------------------------------------------------------------
